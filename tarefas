Exerc√≠cios de Concorr√™ncia em Go

1. Goroutines b√°sicas

Ping-pong sem canais (warm-up)
Implemente duas fun√ß√µes ping() e pong() que imprimem alternadamente ‚Äúping‚Äù e ‚Äúpong‚Äù 10 vezes cada.
Lance ambas como goroutines e garanta que a sa√≠da sempre comece com ‚Äúping‚Äù e termine depois do 10.¬∫ ‚Äúpong‚Äù.

Dica: use time.Sleep uns milissegundos no come√ßo da segunda goroutine para testar interleaving, mas use sync.WaitGroup para aguardar o t√©rmino.

---

2. Channels unbuffered

Cron√¥metro reverso
Receba n via linha de comando e conte de n at√© 0, imprimindo um valor por segundo.

- Fa√ßa a l√≥gica do rel√≥gio em uma goroutine separada que envie o valor atual por um channel sem buffer.
- A goroutine do main apenas recebe e imprime.

Objetivo: sincroniza√ß√£o 1-a-1 sem race conditions.

---

3. Channels buffered

Pipeline de quadrados
Crie tr√™s goroutines em linha:

- Gerador: envia n√∫meros de 1 at√© 1000.
- Elevador: l√™, faz o quadrado (x*x) e repassa.
- Somador: consome tudo e imprime a soma.

Use channels com buffer de 50 entre cada est√°gio e feche-os corretamente. Compare o throughput com buffer 0.

---

4. select e default

Rel√≥gio (tic-tac) com cancelamento

- Imprima ‚Äútic‚Äù a cada 500 ms e ‚Äútac‚Äù a cada segundo.
- Ao apertar Enter, o programa deve parar limpo.
- Use duas goroutines geradoras e um canal de controle que voc√™ monitora com select (inclua um default para evitar dead-lock).

---

5. Communicating Sequential Processes (CSP)

Produtor-consumidor com ‚Äúback-pressure‚Äù

- Implemente 5 produtores que geram inteiros pseudo-aleat√≥rios.
- 2 consumidores que s√≥ processam valores pares.
- O buffer deve ter espa√ßo para 100 valores; se encher, produtores esperam.
- Quando um consumidor processar 10.000 valores, envie sinal para todos cancelarem.
- Me√ßa quantos n√∫meros cada produtor conseguiu gerar antes da parada.

---

6. Estrutura de dados: lista ligada concorrente

LinkedList segura

Modele uma lista simplesmente ligada de inteiros que suporta:

- Insert
- Delete
- Find (m√≠nimo, m√°ximo)

Construa testes de concorr√™ncia com:

- 4 goroutines fazendo inserts
- 2 goroutines fazendo deletes
- 2 goroutines fazendo buscas em ranges sobre 1.000.000 opera√ß√µes

Use mutex ou channels; depois troque o mecanismo e compare performance.

---

7. Estrutura de dados: pool de conex√µes

Pool reutiliz√°vel

Simule um pool de at√© 5 ‚Äúconex√µes‚Äù (strings). Implemente:

Get(ctx context.Context) (Conn, error)
Put(Conn)

- Se n√£o houver conex√£o dispon√≠vel, Get deve bloquear at√© algu√©m devolver ou o contexto ser cancelado.
- A fun√ß√£o main cria 20 goroutines que pegam conex√£o, fazem trabalho de 100 ms e devolvem.
- Ao final, reporte quantas vezes cada conex√£o foi reutilizada.

---

8. Busca de dados paralela

Web-crawler de palavras-chave

- Dado um slice de URLs e uma palavra-alvo, fa√ßa downloads concorrentes (m√°ximo 10 simult√¢neos, respeitando timeout de 5 s por request).
- Conte quantas vezes a palavra aparece em cada p√°gina e devolva um mapa [url]‚Üícount.
- Utilize sync.WaitGroup e um channel de jobs.
- Cancele downloads remanescentes se o usu√°rio apertar Ctrl-C (capturar sinal).

---

9. √çndice invertido em mem√≥ria

Mini-search engine

- Carregue todos os arquivos .txt de um diret√≥rio.
- Construa um √≠ndice que associe cada termo √† lista de arquivos onde ele aparece.
- Exponha um servidor HTTP simples com rota /search?q=foo+bar que devolve JSON com os arquivos que cont√™m todos os termos.
- Fa√ßa o parsing e a indexa√ß√£o em paralelo: cada arquivo √© lido por uma goroutine que envia tokens para um est√°gio de merge seguro por mutex.

---

10. Context avan√ßado

Timeout & retry de RPC

- Simule uma chamada RPC que falha 30% das vezes.
- Escreva CallWithRetry(ctx, nRetries) que:
    - tenta;
    - se erro ‚Äútransient‚Äù, duplica timeout usando context.WithTimeout;
    - cancela corretamente o contexto anterior para evitar leaks.
- Teste com 100 chamadas paralelas e me√ßa lat√™ncia m√©dia.

---

11. Worker pool cancel√°vel

Thumbnailer

- Receba pastas via CLI, busque recursivamente imagens, envie caminhos a um channel de jobs.
- Processe com 4 workers que redimensionam as imagens.
- Use context.WithCancel para abortar tudo se qualquer worker encontrar erro grave (ex: arquivo corrompido).

---

12. Projeto integrador

Chat TCP multi-sala

- Servidor aceita m√∫ltiplas conex√µes.
- Cada sala √© uma goroutine que possui seu pr√≥prio channel de broadcast.
- Clientes podem /join room, /leave, /rooms, /quit.
- Implementar ‚Äúkeep-alive‚Äù: se n√£o receber ping do cliente em 30 s, desconecta.
- Use context.WithCancel para que, ao fechar servidor, todas as salas fechem graceful.

---

Como tirar o m√°ximo proveito

- TDD sempre: crie pequenos testes e rode com go test -race.
- Ferramentas: use go vet, golangci-lint, e o profiler (pprof) para detectar goroutines vazando.
- Leitura paralela: ‚ÄúConcurrency in Go‚Äù (K. Karan) e a se√ß√£o Effective Go sobre concorr√™ncia.
- Compartilhe solu√ß√µes: fa√ßa push no GitHub e pe√ßa code review.

Se quiser gabaritos ou coment√°rios-chave de implementa√ß√£o, √© s√≥ pedir. Bons estudos! üöÄ
